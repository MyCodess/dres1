#!/usr/bin/perl -lw
#
##--II- /perldoc-5.14.0/perltooc.html#The-Eponymous-Meta-Object  +  perldoc-5.14.0/perltooc.html#Locking-the-Door-and-Throwing-Away-the-Key
#	autogenerated aaccessors for invoking- and compiled-class!
#	watch diff between comiling.package ( __PACKAGE__ ) and invoking.package ( ref($obclass) )
#
package Some_Class;
use strict;
##----- create class meta-object using that most perfect of names
our %Some_Class = ( CData1 => "def1", CData2 => "def2",);  ##-- CData==Class.Data as opposite to Object.Data

##----- this accessor is calling-package-relative
sub CData1 {
	my $obclass = shift;	
	my $class   = ref($obclass) || $obclass;
	no strict "refs"; 	# to access eponymous meta-object
	$class->{CData1} = shift if @_;
	return $class->{CData1};
}
##----- but this accessor is not package-relative (is executed in compiled package)
#	you see the diff betwenn two methods by instantiating an obj of a SUBCLASS of this class!!
sub CData2 {
	shift;			# XXX: ignore calling class/object
	no strict "refs"; 	# to access eponymous meta-object
	my $class = __PACKAGE__;
	$class->{CData2} = shift if @_;
	return $class->{CData2};
}

############### kk: test:
#my $obj1= Some_Class->new();
#print $obj1->CData1 = "cd1";

print "__ " .  Some_Class->CData1();
print "__ " .  Some_Class->CData1("cd1");
print "__ " .  Some_Class->CData1();

print "__ " .  Some_Class->CData2();
print "__ " .  Some_Class->CData2("cd2");
print "__ " .  Some_Class->CData2();

__END__
##--II-  also: for all attributes in a private class.data.hash:  see perldoc-5.14.0/perltooc.html#Locking-the-Door-and-Throwing-Away-the-Key :
package Some_Class;
{  # scope for ultra-private meta-object for class attributes
	my %ClassData = ( 
	    CData1 => "",
	    CData2 => "",
	);
	for my $datum (keys %ClassData ) { 
	    no strict "refs";    
	    *$datum = sub {
		use strict "refs";    
		my ($self, $newvalue) = @_;
		$ClassData{$datum} = $newvalue if @_ > 1;
		return $ClassData{$datum};
	    }
	}
}
