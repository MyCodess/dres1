________________ django-prj-try , 1kk-self : _/_230110  :   _____________________________
- django als user/u1 with pip installed in :  /home/u1/.local/lib/python3.10/site-packages/django


#####  ==========  
	_______:  --!! pydoc error for django-modules:
	 pydoc NOT working with many django classes (due to their the __init__ files content, which will be basically executed by any import bzw. pydoc-call !)
	thein inits require also a valid django-project-setting-file!
	so you can work-around it with a dummy prj somewhere in your PYTHONPATH and then save the following in eg django-pydoc.py , and call it with: python ./django-pydoc.py  django.db.models.fields.DateField
	so eg: cp -a ./djp1/  /up1/prjs/py1/libs/djp1/ ; export PYTHONPATH=/up1/prjs/py1/libs/djp1/:${PYTHONPATH} ; python ./django-pydoc.py  django.db.models.fields.DateField
import os
import django
import pydoc
os.environ['DJANGO_SETTINGS_MODULE'] = 'djp1.settings'  ##--!-adapt this to set to your dummy/empty-prj! must be eplorable by python/PYTHONPATH !
django.setup()
pydoc.cli()
##________________________________________  ___________________________


#####  ==========  ========== coll-steps.... dj1-prj : ========================================================
- prj: djp1 ; app: cb1 ; db: db1 ; RootDP: dj1home ; djangp-ver-4.1.5 /_230111  ;

	_______:  -- DB1-exp for app1:  contactbook/ cb1 : see 1kk-exp-db:  /up1/w1/dc1k/dres/dnts/dbs-sqls_dnts/sqlite-create-db1-contactbook1.sql as:
create table peop1 (id INTEGER PRIMARY KEY, name varchar(100), tel int, email varchar(50) UNIQUE, birth datetime ) ;
create table adr1 (id INTEGER PRIMARY KEY, street varchar(100), plz int, city varchar(50), updated datetime, FOREIGN KEY(id) REFERENCES peop1(id) ) ;

	_______:  -- pri-create:
[u1@2209arx dj1home]$ django-admin   startproject  djp1
/up1/prjs/py1/wks/dj1home    bzw.     /up1/mnt/VARUfs/varu/varau/prjs/py1/wks/dj1home
Tue Jan 10 05:17:03 PM CET 2023

	_______:  -- app-create: cb1  in /up1/prjs/py1/wks/dj1home/djp1 :
python manage.py  startapp  cb1

	_______:  --- urls, settings, ...:
	vi ./djp1/urls.py  ##add: path('cb1_RP/', include('cb1.urls')),  ##--so the basic-web-url would be: http://127.0.0.1:8000/cb1_RP/
	vi  ./djp1/settings.py  ##-- INSTALLED_APPS = [ 'cb1.apps.Cb1Config', ... ]
	.... (not all steps here vlt. eingetragen ...!)
	runserver and check th urls:  http://127.0.0.1:8000/cb1_RP/

	_______:  -- DB-create with basic django schema tables, yet without any app-specific tables/models:
#- The migrate command looks at the INSTALLED_APPS setting and creates any necessary database tables according to the database settings in your mysite/settings.py file and the database migrations shipped with the app
cd prj1-dir: /up1/prjs/py1/wks/dj1home/djp1 
[u1@2209arx djp1]$ python manage.py   migrate  #--->  created db1.sqlite3 with apps-schemas defined in settings.py

	_______:  -- Models-Creation /OR-Mapping (Model-Classes-edit/create + Model-Classes-Generation + DBTables-commits) :
	three-step guide to making model changes:
	1- Change/create your models/classes in models.py
	2- Run python manage.py makemigrations to create migrations for those changes (as autogenerated:  ./cb1/migrations/0001_initial.py)
	3- Run python manage.py migrate to apply those changes to the database. ()
	see below for deatiled exp steps:

	_______:  -- model-classes-op-app-creation + DBObjects-creation (mapping into DB-tables):
1- model-classes-creation:
	vi  ./cb1/models.py  ##--> define there your models/db-objects/db-tables of your app
	-!! for every Model-class (db-table) django adds implicitely the autoincrement-int-primary-key! so yo do NOT need to add it in your model-class !
	  so Primary keys (IDs) are added automatically. (You can override this, too.)
	add models to prj1-apps:  vi ./djp1/settings.py ; INSTALLED_APPS = [ 'cb1.apps.Cb1Config' , ... ]
2- autogeneration of  DB-Objects (Model-Obects) classes :
	[u1@2209arx djp1]$  python   manage.py   makemigrations  cb1
	Migrations for 'cb1':
	  cb1/migrations/0001_initial.py
		- Create model Peop1
		- Create model Adr1
	[u1@2209arx djp1]$
	chk/see created model-obj:  vi  ./cb1/migrations/0001_initial.py
3- DB-Tables-mapping/commiting:
- create DB-Talbes / SQL-actions : simulation: (sqlmigrate do NOT write into DB yet, but shows the SQL-Stmts which wil be executed with migrate command):
	[u1@2209arx djp1]$ python  manage.py   sqlmigrate   cb1 0001
	BEGIN;
	--
	-- Create model Peop1
	--
	CREATE TABLE "cb1_peop1" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(100) NOT NULL, "tel" integer NOT NULL, "email" varchar(100) NOT NULL, "birth" date NOT NULL);
	--
	-- Create model Adr1
	--
	CREATE TABLE "cb1_adr1" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "street" varchar(100) NOT NULL, "plz" integer NOT NULL, "city" varchar(100) NOT NULL, "updated" datetime NOT NULL, "peop1_fk1_id" bigint NOT NULL REFERENCES "cb1_peop1" ("id") DEFERRABLE INITIALLY DEFERRED);
	CREATE INDEX "cb1_adr1_peop1_fk1_id_73d52645" ON "cb1_adr1" ("peop1_fk1_id");
	COMMIT;
	[u1@2209arx djp1]$ 
-
create DB-Talbes / SQL-actions :
	[u1@2209arx djp1]$ python  manage.py   migrate
	Operations to perform: Apply all migrations: admin, auth, cb1, contenttypes, sessions
	Running migrations: Applying cb1.0001_initial... OK
	[u1@2209arx djp1]$ 
chk: DB-Browsing ! tablename are: appName_modelClassName
-! The migrate command takes all the migrations that havenâ€™t been applied (Django tracks which ones are applied using a special table in your database called django_migrations) and runs them against your database - essentially, synchronizing the changes you made to your models with the schema in the database. (1kk: so you can execute it several times/redundant.)

	_______:  -- playing-API from django-Shell / checkings with the django-API:
- vi ./cb1/models.py  ##--add __str__ mothods to the classes for later printouts !
- django-Shell : from prj1-dir:
	$ python manage.py shell  ##--> so goes to python sehll but with  sets the DJANGO_SETTINGS_MODULE environment variable, which gives Django the Python import path to your mysite/settings.py file ... !
--
>>> from cb1.models import Peop1, Adr1
>>> from datetime import date as d
>>> from datetime import datetime  as dt
>>> p1=Peop1(name="aaa", tel=111, email="aa@aa.aa", birth=d(2001,1,1))
>>> p1.save()   ##--now chek the DB ! the entry must be there!
>>> Peop1.objects.all()
>>> a1=Adr1(street="str1-no1", plz=1000, city="aaa@aaa", updated=d(2011,11,11))
>>> a2.peop1_fk1_id=2 ##setting FK , FK-atrib-name = <constraint-name-in-class/model.py>_id
>>> a2.save() ##--wroteinto DB!
#-change/adapt __str__() to see better, and then reload the class from the module (importlib.reload() works for modules, not a class-inside-a-module !):
>>> del sys.modules["cb1.models"] ; from cb1.models import Peop1, Adr1 ; ##--ignore warnings of dj for reloading
>>> print (a2)
##--- queries / filtering/searching for entries:
>>> Peop1.objects.get(pk=4)
>>> Peop1.objects.filter(pk=1)
>>> Adr1.objects.filter(id=2)
>>> Adr1.objects.filter(plz=1000)
>>> Adr1.objects.filter.get(pk=2)
##-- create a related elements per FK for an  Object:
>>> p1=Peop1.objects.get(pk=1)
>>> p1.adr1_set.all()
>>> p1.adr1_set.create(street="created1-p4")   ##--create a NEW Adr1-obj with FK to p1 and street=crea... ; instantly is also saved in DB !
##-- listin all entries in Peop1 :
>>> l1=Peop1.objects.all()
>>> for ii in l1: print (ii)
##--query related elements per FK for an  Object:
>>> p1=Peop1.objects.get(pk=1)
>>> p1.adr1_set.all()
>>> for ii in p1.adr1_set.all(): print (ii)
##-- for more details see the links at the end of Tut-Part-2 :
For more information on model relations, see Accessing related objects. For more on how to use double underscores to perform field lookups via the API, see Field lookups. For full details on the database API, see our Database API reference.

	_______:  -- admin-app:
	/up1/prjs/py1/wks/dj1home/djp1
	Creating an admin user
	$ python manage.py createsuperuser  : adm1 + adm1 + dm1@adm1.org  ##---> entries in DB/auth_user-table,....
	# user:   dj-us1 + dj-us1-dj-us1
	#-- integrating admin-site and your-app together, so admin also for your cb1:
	#--> so now you can edit Peop1-entries through admin-portal !
	check urls:  http://127.0.0.1:8000/admin/ , ...

	_______:  -- views:
	vi  ./cb1/views.py  ##--add some view-funcs there!
	vi  ./cb1/urls.py   ##--url-mapping enter there!
	web-server:  python manage.py  runserver
	check the urls:  http://127.0.0.1:8000/cb1_RP/1  ##--!- if .../1/ then in the ./cb1/urls.py must exist also an end-slash as: path('<int:peop_id>/',... !!

	_______:  --!! URL-resolution / request/responce-resolution (here prj ist djp1 and app is cb1 ): so when an URL is called, then:
	1- check in ./djp1/urls.py : urlpatterns  to find a match! if finds -->
	2- forwarded to the app of the Rest-url (the app must be also in ./djp1/settings.py : INSTALLED_APPS ), so after /app-name/...
	3- check in the ./cb1/urls.py to find the relevant view, if find ->
	4- resolve the vars (as <int:peop_id>/ so assign to peop_id the request-part)
	5- call the assigned view of the rest-URl
	6- send its response back !
	so exp:
	http://127.0.0.1:8000/cb1_RP/1/  -- see in ./djp1/urls.py path('cb1_RP/', include('cb1.urls')) AND cb1 is an installed app in ./djp1/settings.py , so ->
	check in ./cb1/urls.py for "/1/"  ,finds match of path('<int:peop_id>/', views.detail, name='detail1-name'), so ->
	assigns peop_id=1 and calls views.detail ,so in ./cb1/views.py the def detail(request, peop_id): ... ->
	and gets its returned HttpResponse and back to the client !
	- see also refTut-part3, after edit of polls/urls.py !
